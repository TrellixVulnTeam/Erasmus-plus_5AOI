import {
  EJSON,
  ObjectId,
  bson_browser_esm_exports,
  init_bson_browser_esm
} from "./chunk-DM74JUME.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-XYVWA2NS.js";

// node_modules/realm-web/dist/bundle.dom.es.js
init_bson_browser_esm();
init_bson_browser_esm();
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version2, os) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version2) {
    this.version = version2;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version2, os, bot) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
var DefaultNetworkTransport = class {
  constructor() {
    if (!DefaultNetworkTransport.fetch) {
      throw new Error("DefaultNetworkTransport.fetch must be set before it's used");
    }
    if (!DefaultNetworkTransport.AbortController) {
      throw new Error("DefaultNetworkTransport.AbortController must be set before it's used");
    }
  }
  fetchWithCallbacks(request, handler) {
    this.fetch(request).then(async (response) => {
      const decodedBody = await response.text();
      const responseHeaders = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });
      return {
        statusCode: response.status,
        headers: responseHeaders,
        body: decodedBody
      };
    }).then((r) => handler.onSuccess(r)).catch((e) => handler.onError(e));
  }
  async fetch(request) {
    const _a = request, { timeoutMs, url } = _a, rest = __objRest(_a, ["timeoutMs", "url"]);
    const { signal, cancelTimeout } = this.createTimeoutSignal(timeoutMs);
    try {
      return await DefaultNetworkTransport.fetch(url, __spreadValues(__spreadProps(__spreadValues({}, DefaultNetworkTransport.extraFetchOptions), {
        signal
      }), rest));
    } finally {
      cancelTimeout();
    }
  }
  createTimeoutSignal(timeoutMs) {
    if (typeof timeoutMs === "number") {
      const controller = new DefaultNetworkTransport.AbortController();
      const timeout = setTimeout(() => {
        controller.abort();
      }, timeoutMs);
      return {
        signal: controller.signal,
        cancelTimeout: () => {
          clearTimeout(timeout);
        }
      };
    } else {
      return {
        signal: void 0,
        cancelTimeout: () => {
        }
      };
    }
  }
};
DefaultNetworkTransport.DEFAULT_HEADERS = {
  "Content-Type": "application/json"
};
DefaultNetworkTransport.fetch = globalThis.fetch.bind(globalThis);
DefaultNetworkTransport.AbortController = globalThis.AbortController;
var version = "3.7.2";
var VERSION = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI,
  encodeURL: encodeURI,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var SERIALIZATION_OPTIONS = {
  relaxed: false
};
function serialize(obj) {
  return EJSON.serialize(obj, SERIALIZATION_OPTIONS);
}
function deserialize(obj) {
  if (Array.isArray(obj)) {
    return obj.map((doc) => EJSON.deserialize(doc));
  } else {
    return EJSON.deserialize(obj);
  }
}
var UserType;
(function(UserType2) {
  UserType2["Normal"] = "normal";
  UserType2["Server"] = "server";
})(UserType || (UserType = {}));
var DataKey;
(function(DataKey2) {
  DataKey2["NAME"] = "name";
  DataKey2["EMAIL"] = "email";
  DataKey2["PICTURE"] = "picture";
  DataKey2["FIRST_NAME"] = "first_name";
  DataKey2["LAST_NAME"] = "last_name";
  DataKey2["GENDER"] = "gender";
  DataKey2["BIRTHDAY"] = "birthday";
  DataKey2["MIN_AGE"] = "min_age";
  DataKey2["MAX_AGE"] = "max_age";
})(DataKey || (DataKey = {}));
var DATA_MAPPING = {
  [DataKey.NAME]: "name",
  [DataKey.EMAIL]: "email",
  [DataKey.PICTURE]: "pictureUrl",
  [DataKey.FIRST_NAME]: "firstName",
  [DataKey.LAST_NAME]: "lastName",
  [DataKey.GENDER]: "gender",
  [DataKey.BIRTHDAY]: "birthday",
  [DataKey.MIN_AGE]: "minAge",
  [DataKey.MAX_AGE]: "maxAge"
};
var UserProfile = class {
  constructor(response) {
    this.type = UserType.Normal;
    this.identities = [];
    if (typeof response === "object" && response !== null) {
      const { type, identities, data } = response;
      if (typeof type === "string") {
        this.type = type;
      } else {
        throw new Error("Expected 'type' in the response body");
      }
      if (Array.isArray(identities)) {
        this.identities = identities.map((identity) => {
          const { id, provider_type: providerType } = identity;
          return { id, providerType };
        });
      } else {
        throw new Error("Expected 'identities' in the response body");
      }
      if (typeof data === "object" && data !== null) {
        const mappedData = Object.fromEntries(Object.entries(data).map(([key, value]) => {
          if (key in DATA_MAPPING) {
            return [DATA_MAPPING[key], value];
          } else {
            return [key, value];
          }
        }));
        this.data = deserialize(mappedData);
      } else {
        throw new Error("Expected 'data' in the response body");
      }
    } else {
      this.data = {};
    }
  }
};
var PrefixedStorage = class {
  constructor(storage, keyPart) {
    this.storage = storage;
    this.keyPart = keyPart;
  }
  get(key) {
    return this.storage.get(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);
  }
  set(key, value) {
    return this.storage.set(this.keyPart + PrefixedStorage.PART_SEPARATOR + key, value);
  }
  remove(key) {
    return this.storage.remove(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);
  }
  prefix(keyPart) {
    return new PrefixedStorage(this, keyPart);
  }
  clear(prefix = "") {
    return this.storage.clear(this.keyPart + PrefixedStorage.PART_SEPARATOR + prefix);
  }
  addListener(listener) {
    return this.storage.addListener(listener);
  }
  removeListener(listener) {
    return this.storage.addListener(listener);
  }
};
PrefixedStorage.PART_SEPARATOR = ":";
var MemoryStorage = class {
  constructor() {
    this.storage = {};
    this.listeners = /* @__PURE__ */ new Set();
  }
  get(key) {
    if (key in this.storage) {
      return this.storage[key];
    } else {
      return null;
    }
  }
  set(key, value) {
    this.storage[key] = value;
    this.fireListeners();
  }
  remove(key) {
    delete this.storage[key];
    this.fireListeners();
  }
  prefix(keyPart) {
    return new PrefixedStorage(this, keyPart);
  }
  clear(prefix) {
    for (const key of Object.keys(this.storage)) {
      if (!prefix || key.startsWith(prefix)) {
        delete this.storage[key];
      }
    }
    this.fireListeners();
  }
  addListener(listener) {
    this.listeners.add(listener);
  }
  removeListener(listener) {
    this.listeners.delete(listener);
  }
  fireListeners() {
    this.listeners.forEach((listener) => listener());
  }
};
var ACCESS_TOKEN_STORAGE_KEY = "accessToken";
var REFRESH_TOKEN_STORAGE_KEY = "refreshToken";
var PROFILE_STORAGE_KEY = "profile";
var PROVIDER_TYPE_STORAGE_KEY = "providerType";
var UserStorage = class extends PrefixedStorage {
  constructor(storage, userId) {
    super(storage, `user(${userId})`);
  }
  get accessToken() {
    return this.get(ACCESS_TOKEN_STORAGE_KEY);
  }
  set accessToken(value) {
    if (value === null) {
      this.remove(ACCESS_TOKEN_STORAGE_KEY);
    } else {
      this.set(ACCESS_TOKEN_STORAGE_KEY, value);
    }
  }
  get refreshToken() {
    return this.get(REFRESH_TOKEN_STORAGE_KEY);
  }
  set refreshToken(value) {
    if (value === null) {
      this.remove(REFRESH_TOKEN_STORAGE_KEY);
    } else {
      this.set(REFRESH_TOKEN_STORAGE_KEY, value);
    }
  }
  get profile() {
    const value = this.get(PROFILE_STORAGE_KEY);
    if (value) {
      const profile = new UserProfile();
      Object.assign(profile, JSON.parse(value));
      return profile;
    }
  }
  set profile(value) {
    if (value) {
      this.set(PROFILE_STORAGE_KEY, JSON.stringify(value));
    } else {
      this.remove(PROFILE_STORAGE_KEY);
    }
  }
  get providerType() {
    const value = this.get(PROVIDER_TYPE_STORAGE_KEY);
    if (value) {
      return value;
    }
  }
  set providerType(value) {
    if (value) {
      this.set(PROVIDER_TYPE_STORAGE_KEY, value);
    } else {
      this.remove(PROVIDER_TYPE_STORAGE_KEY);
    }
  }
};
function removeKeysWithUndefinedValues(obj) {
  return Object.fromEntries(Object.entries(obj).filter((entry) => typeof entry[1] !== "undefined"));
}
function generateRandomString(length, alphabet) {
  let result = "";
  for (let i = 0; i < length; i++) {
    result += alphabet[Math.floor(Math.random() * alphabet.length)];
  }
  return result;
}
function encodeQueryString(params, prefixed = true) {
  const cleanedParams = removeKeysWithUndefinedValues(params);
  const prefix = prefixed && Object.keys(cleanedParams).length > 0 ? "?" : "";
  return prefix + Object.entries(cleanedParams).map(([k, v]) => `${k}=${encodeURIComponent(v)}`).join("&");
}
function decodeQueryString(str) {
  const cleanStr = str[0] === "?" ? str.substr(1) : str;
  return Object.fromEntries(cleanStr.split("&").filter((s) => s.length > 0).map((kvp) => kvp.split("=")).map(([k, v]) => [k, decodeURIComponent(v)]));
}
var RESERVED_NAMES = [
  "inspect",
  "callFunction",
  "callFunctionStreaming",
  ...Object.getOwnPropertyNames(Object.prototype)
];
function cleanArgs(args) {
  for (const arg of args) {
    if (typeof arg === "object" && arg) {
      for (const [key, value] of Object.entries(arg)) {
        if (value === void 0) {
          delete arg[key];
        }
      }
    }
  }
  return args;
}
function cleanArgsAndSerialize(args) {
  const cleaned = cleanArgs(args);
  return cleaned.map((arg) => typeof arg === "object" ? serialize(arg) : arg);
}
var FunctionsFactory = class {
  constructor(fetcher, config = {}) {
    this.fetcher = fetcher;
    this.serviceName = config.serviceName;
    this.argsTransformation = config.argsTransformation || cleanArgsAndSerialize;
  }
  static create(fetcher, config = {}) {
    const factory = new FunctionsFactory(fetcher, config);
    return new Proxy(factory, {
      get(target, p, receiver) {
        if (typeof p === "string" && RESERVED_NAMES.indexOf(p) === -1) {
          return target.callFunction.bind(target, p);
        } else {
          const prop = Reflect.get(target, p, receiver);
          return typeof prop === "function" ? prop.bind(target) : prop;
        }
      }
    });
  }
  async callFunction(name, ...args) {
    const body = {
      name,
      arguments: this.argsTransformation ? this.argsTransformation(args) : args
    };
    if (this.serviceName) {
      body.service = this.serviceName;
    }
    const appRoute = this.fetcher.appRoute;
    return this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.functionsCall().path,
      body
    });
  }
  callFunctionStreaming(name, ...args) {
    const body = {
      name,
      arguments: this.argsTransformation ? this.argsTransformation(args) : args
    };
    if (this.serviceName) {
      body.service = this.serviceName;
    }
    const appRoute = this.fetcher.appRoute;
    const qs = encodeQueryString({
      ["baas_request"]: gBase64.encode(JSON.stringify(body))
    });
    return this.fetcher.fetchStream({
      method: "GET",
      path: appRoute.functionsCall().path + qs
    });
  }
};
var isDevelopmentMode = false;
var setIsDevelopmentMode = (state) => {
  isDevelopmentMode = state;
};
var deprecationWarning = (deprecatedItem, suggestedReplacement) => {
  if (!isDevelopmentMode)
    return;
  console.warn(`Deprecation warning from Realm: ${deprecatedItem} is deprecated and will be removed in a future major release. Consider switching to ${suggestedReplacement}.`);
};
var handleDeprecatedPositionalArgs = (args, methodName, argNames, hasRestArgs) => {
  if (typeof args[0] !== "object") {
    const restArgsText = hasRestArgs ? ", ...args" : "";
    deprecationWarning(`${methodName}(${argNames.join(", ")}${restArgsText})`, `${methodName}({ ${argNames.join(", ")} }${restArgsText})`);
    const argsObject = argNames.reduce((prev, argName, index) => {
      return __spreadProps(__spreadValues({}, prev), { [argName]: args[index] });
    }, {});
    const restArgs = hasRestArgs ? args.slice(argNames.length) : void 0;
    return { argsObject, restArgs };
  }
  return { argsObject: args[0], restArgs: hasRestArgs ? args.slice(1) : void 0 };
};
setIsDevelopmentMode(typeof __DEV__ !== "undefined" && __DEV__);
var EmailPasswordAuth = class {
  constructor(fetcher, providerName = "local-userpass") {
    this.fetcher = fetcher;
    this.providerName = providerName;
  }
  async registerUser(...args) {
    const { argsObject: userDetails } = handleDeprecatedPositionalArgs(args, "registerUser", ["email", "password"]);
    const appRoute = this.fetcher.appRoute;
    await this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.emailPasswordAuth(this.providerName).register().path,
      body: userDetails
    });
  }
  async confirmUser(...args) {
    const { argsObject: tokenDetails } = handleDeprecatedPositionalArgs(args, "confirmUser", ["token", "tokenId"]);
    const appRoute = this.fetcher.appRoute;
    await this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.emailPasswordAuth(this.providerName).confirm().path,
      body: tokenDetails
    });
  }
  async resendConfirmationEmail(...args) {
    const { argsObject: emailDetails } = handleDeprecatedPositionalArgs(args, "resendConfirmationEmail", ["email"]);
    const appRoute = this.fetcher.appRoute;
    await this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.emailPasswordAuth(this.providerName).confirmSend().path,
      body: emailDetails
    });
  }
  async retryCustomConfirmation(...args) {
    const { argsObject: emailDetails } = handleDeprecatedPositionalArgs(args, "retryCustomConfirmation", ["email"]);
    const appRoute = this.fetcher.appRoute;
    await this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.emailPasswordAuth(this.providerName).confirmCall().path,
      body: emailDetails
    });
  }
  async resetPassword(...args) {
    const { argsObject: resetDetails } = handleDeprecatedPositionalArgs(args, "resetPassword", ["token", "tokenId", "password"]);
    const appRoute = this.fetcher.appRoute;
    await this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.emailPasswordAuth(this.providerName).reset().path,
      body: resetDetails
    });
  }
  async sendResetPasswordEmail(...args) {
    const { argsObject: emailDetails } = handleDeprecatedPositionalArgs(args, "sendResetPasswordEmail", ["email"]);
    const appRoute = this.fetcher.appRoute;
    await this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.emailPasswordAuth(this.providerName).resetSend().path,
      body: emailDetails
    });
  }
  async callResetPasswordFunction(...args) {
    const { argsObject: resetDetails, restArgs } = handleDeprecatedPositionalArgs(args, "callResetPasswordFunction", ["email", "password"], true);
    const appRoute = this.fetcher.appRoute;
    await this.fetcher.fetchJSON({
      method: "POST",
      path: appRoute.emailPasswordAuth(this.providerName).resetCall().path,
      body: __spreadProps(__spreadValues({}, resetDetails), { arguments: restArgs })
    });
  }
};
function api() {
  return {
    path: "/api/client/v2.0",
    app(appId) {
      return {
        path: this.path + `/app/${appId}`,
        location() {
          return {
            path: this.path + "/location"
          };
        },
        authProvider(providerName) {
          return {
            path: this.path + `/auth/providers/${providerName}`,
            login() {
              return { path: this.path + "/login" };
            }
          };
        },
        emailPasswordAuth(providerName) {
          const authProviderRoutes = this.authProvider(providerName);
          return __spreadProps(__spreadValues({}, authProviderRoutes), {
            register() {
              return { path: this.path + "/register" };
            },
            confirm() {
              return { path: this.path + "/confirm" };
            },
            confirmSend() {
              return { path: this.path + "/confirm/send" };
            },
            confirmCall() {
              return { path: this.path + "/confirm/call" };
            },
            reset() {
              return { path: this.path + "/reset" };
            },
            resetSend() {
              return { path: this.path + "/reset/send" };
            },
            resetCall() {
              return { path: this.path + "/reset/call" };
            }
          });
        },
        functionsCall() {
          return {
            path: this.path + "/functions/call"
          };
        }
      };
    },
    auth() {
      return {
        path: this.path + "/auth",
        apiKeys() {
          return {
            path: this.path + "/api_keys",
            key(id) {
              return {
                path: this.path + `/${id}`,
                enable() {
                  return { path: this.path + "/enable" };
                },
                disable() {
                  return { path: this.path + "/disable" };
                }
              };
            }
          };
        },
        profile() {
          return { path: this.path + "/profile" };
        },
        session() {
          return { path: this.path + "/session" };
        },
        delete() {
          return { path: this.path + "/delete" };
        }
      };
    }
  };
}
var routes = { api };
var ApiKeyAuth = class {
  constructor(fetcher) {
    this.fetcher = fetcher;
  }
  create(name) {
    return this.fetcher.fetchJSON({
      method: "POST",
      body: { name },
      path: routes.api().auth().apiKeys().path,
      tokenType: "refresh"
    });
  }
  fetch(keyId) {
    return this.fetcher.fetchJSON({
      method: "GET",
      path: routes.api().auth().apiKeys().key(keyId).path,
      tokenType: "refresh"
    });
  }
  fetchAll() {
    return this.fetcher.fetchJSON({
      method: "GET",
      tokenType: "refresh",
      path: routes.api().auth().apiKeys().path
    });
  }
  async delete(keyId) {
    await this.fetcher.fetchJSON({
      method: "DELETE",
      path: routes.api().auth().apiKeys().key(keyId).path,
      tokenType: "refresh"
    });
  }
  async enable(keyId) {
    await this.fetcher.fetchJSON({
      method: "PUT",
      path: routes.api().auth().apiKeys().key(keyId).enable().path,
      tokenType: "refresh"
    });
  }
  async disable(keyId) {
    await this.fetcher.fetchJSON({
      method: "PUT",
      path: routes.api().auth().apiKeys().key(keyId).disable().path,
      tokenType: "refresh"
    });
  }
};
var environment = null;
function setEnvironment(e) {
  environment = e;
}
function getEnvironment() {
  if (environment) {
    return environment;
  } else {
    throw new Error("Cannot get environment before it's set");
  }
}
var WatchError = class extends Error {
  constructor({ message, code }) {
    super(message);
    this.name = "WatchError";
    this.code = code;
  }
};
var WatchStreamState;
(function(WatchStreamState2) {
  WatchStreamState2["NEED_DATA"] = "NEED_DATA";
  WatchStreamState2["HAVE_EVENT"] = "HAVE_EVENT";
  WatchStreamState2["HAVE_ERROR"] = "HAVE_ERROR";
})(WatchStreamState || (WatchStreamState = {}));
var WatchStream = class {
  constructor() {
    this._state = WatchStreamState.NEED_DATA;
    this._error = null;
    this._textDecoder = new (getEnvironment()).TextDecoder();
    this._buffer = "";
    this._bufferOffset = 0;
    this._eventType = "";
    this._dataBuffer = "";
  }
  feedBuffer(buffer) {
    this.assertState(WatchStreamState.NEED_DATA);
    this._buffer += this._textDecoder.decode(buffer, { stream: true });
    this.advanceBufferState();
  }
  feedLine(line) {
    this.assertState(WatchStreamState.NEED_DATA);
    if (line.endsWith("\n"))
      line = line.substr(0, line.length - 1);
    if (line.endsWith("\r"))
      line = line.substr(0, line.length - 1);
    if (line.length === 0) {
      if (this._dataBuffer.length === 0) {
        this._eventType = "";
        return;
      }
      if (this._dataBuffer.endsWith("\n"))
        this._dataBuffer = this._dataBuffer.substr(0, this._dataBuffer.length - 1);
      this.feedSse({
        data: this._dataBuffer,
        eventType: this._eventType
      });
      this._dataBuffer = "";
      this._eventType = "";
    }
    if (line[0] === ":")
      return;
    const colon = line.indexOf(":");
    const field = line.substr(0, colon);
    let value = colon === -1 ? "" : line.substr(colon + 1);
    if (value.startsWith(" "))
      value = value.substr(1);
    if (field === "event") {
      this._eventType = value;
    } else if (field === "data") {
      this._dataBuffer += value;
      this._dataBuffer += "\n";
    } else
      ;
  }
  feedSse(sse) {
    this.assertState(WatchStreamState.NEED_DATA);
    const firstPercentIndex = sse.data.indexOf("%");
    if (firstPercentIndex !== -1) {
      let buffer = "";
      let start = 0;
      for (let percentIndex = firstPercentIndex; percentIndex !== -1; percentIndex = sse.data.indexOf("%", start)) {
        buffer += sse.data.substr(start, percentIndex - start);
        const encoded = sse.data.substr(percentIndex, 3);
        if (encoded === "%25") {
          buffer += "%";
        } else if (encoded === "%0A") {
          buffer += "\n";
        } else if (encoded === "%0D") {
          buffer += "\r";
        } else {
          buffer += encoded;
        }
        start = percentIndex + encoded.length;
      }
      buffer += sse.data.substr(start);
      sse.data = buffer;
    }
    if (!sse.eventType || sse.eventType === "message") {
      try {
        const parsed = EJSON.parse(sse.data);
        if (typeof parsed === "object") {
          this._nextEvent = parsed;
          this._state = WatchStreamState.HAVE_EVENT;
          return;
        }
      } catch {
      }
      this._state = WatchStreamState.HAVE_ERROR;
      this._error = new WatchError({
        message: "server returned malformed event: " + sse.data,
        code: "bad bson parse"
      });
    } else if (sse.eventType === "error") {
      this._state = WatchStreamState.HAVE_ERROR;
      this._error = new WatchError({
        message: sse.data,
        code: "unknown"
      });
      try {
        const { error_code: errorCode, error } = EJSON.parse(sse.data);
        if (typeof errorCode !== "string")
          return;
        if (typeof error !== "string")
          return;
        this._error = new WatchError({
          message: error,
          code: errorCode
        });
      } catch {
        return;
      }
    } else
      ;
  }
  get state() {
    return this._state;
  }
  nextEvent() {
    this.assertState(WatchStreamState.HAVE_EVENT);
    const out = this._nextEvent;
    this._state = WatchStreamState.NEED_DATA;
    this.advanceBufferState();
    return out;
  }
  get error() {
    return this._error;
  }
  advanceBufferState() {
    this.assertState(WatchStreamState.NEED_DATA);
    while (this.state === WatchStreamState.NEED_DATA) {
      if (this._bufferOffset === this._buffer.length) {
        this._buffer = "";
        this._bufferOffset = 0;
        return;
      }
      const nextNewlineIndex = this._buffer.indexOf("\n", this._bufferOffset);
      if (nextNewlineIndex === -1) {
        if (this._bufferOffset !== 0) {
          this._buffer = this._buffer.substr(this._bufferOffset, this._buffer.length - this._bufferOffset);
          this._bufferOffset = 0;
        }
        return;
      }
      this.feedLine(this._buffer.substr(this._bufferOffset, nextNewlineIndex - this._bufferOffset));
      this._bufferOffset = nextNewlineIndex + 1;
    }
  }
  assertState(state) {
    if (this._state !== state) {
      throw Error(`Expected WatchStream to be in state ${state}, but in state ${this._state}`);
    }
  }
};
var MongoDBCollection = class {
  constructor(fetcher, serviceName, databaseName, collectionName) {
    this.functions = FunctionsFactory.create(fetcher, {
      serviceName
    });
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.serviceName = serviceName;
    this.fetcher = fetcher;
  }
  find(filter = {}, options = {}) {
    return this.functions.find({
      database: this.databaseName,
      collection: this.collectionName,
      query: filter,
      project: options.projection,
      sort: options.sort,
      limit: options.limit
    });
  }
  findOne(filter = {}, options = {}) {
    return this.functions.findOne({
      database: this.databaseName,
      collection: this.collectionName,
      query: filter,
      project: options.projection,
      sort: options.sort
    });
  }
  findOneAndUpdate(filter = {}, update, options = {}) {
    return this.functions.findOneAndUpdate({
      database: this.databaseName,
      collection: this.collectionName,
      filter,
      update,
      sort: options.sort,
      projection: options.projection,
      upsert: options.upsert,
      returnNewDocument: options.returnNewDocument
    });
  }
  findOneAndReplace(filter = {}, replacement, options = {}) {
    return this.functions.findOneAndReplace({
      database: this.databaseName,
      collection: this.collectionName,
      filter,
      update: replacement,
      sort: options.sort,
      projection: options.projection,
      upsert: options.upsert,
      returnNewDocument: options.returnNewDocument
    });
  }
  findOneAndDelete(filter = {}, options = {}) {
    return this.functions.findOneAndReplace({
      database: this.databaseName,
      collection: this.collectionName,
      filter,
      sort: options.sort,
      projection: options.projection
    });
  }
  aggregate(pipeline) {
    return this.functions.aggregate({
      database: this.databaseName,
      collection: this.collectionName,
      pipeline
    });
  }
  count(filter = {}, options = {}) {
    return this.functions.count({
      database: this.databaseName,
      collection: this.collectionName,
      query: filter,
      limit: options.limit
    });
  }
  insertOne(document2) {
    return this.functions.insertOne({
      database: this.databaseName,
      collection: this.collectionName,
      document: document2
    });
  }
  insertMany(documents) {
    return this.functions.insertMany({
      database: this.databaseName,
      collection: this.collectionName,
      documents
    });
  }
  deleteOne(filter = {}) {
    return this.functions.deleteOne({
      database: this.databaseName,
      collection: this.collectionName,
      query: filter
    });
  }
  deleteMany(filter = {}) {
    return this.functions.deleteMany({
      database: this.databaseName,
      collection: this.collectionName,
      query: filter
    });
  }
  updateOne(filter, update, options = {}) {
    return this.functions.updateOne({
      database: this.databaseName,
      collection: this.collectionName,
      query: filter,
      update,
      upsert: options.upsert,
      arrayFilters: options.arrayFilters
    });
  }
  updateMany(filter, update, options = {}) {
    return this.functions.updateMany({
      database: this.databaseName,
      collection: this.collectionName,
      query: filter,
      update,
      upsert: options.upsert,
      arrayFilters: options.arrayFilters
    });
  }
  async *watch({ ids, filter } = {}) {
    const iterator = await this.functions.callFunctionStreaming("watch", {
      database: this.databaseName,
      collection: this.collectionName,
      ids,
      filter
    });
    const watchStream = new WatchStream();
    for await (const chunk of iterator) {
      if (!chunk)
        continue;
      watchStream.feedBuffer(chunk);
      while (watchStream.state == WatchStreamState.HAVE_EVENT) {
        yield watchStream.nextEvent();
      }
      if (watchStream.state == WatchStreamState.HAVE_ERROR)
        throw watchStream.error;
    }
  }
};
function createCollection(fetcher, serviceName, databaseName, collectionName) {
  return new MongoDBCollection(fetcher, serviceName, databaseName, collectionName);
}
function createDatabase(fetcher, serviceName, databaseName) {
  return {
    collection: createCollection.bind(null, fetcher, serviceName, databaseName)
  };
}
function createService(fetcher, serviceName = "mongo-db") {
  return { db: createDatabase.bind(null, fetcher, serviceName) };
}
var DEFAULT_DEVICE_ID = "000000000000000000000000";
var UserState;
(function(UserState2) {
  UserState2["Active"] = "active";
  UserState2["LoggedOut"] = "logged-out";
  UserState2["Removed"] = "removed";
})(UserState || (UserState = {}));
var UserType$1;
(function(UserType2) {
  UserType2["Normal"] = "normal";
  UserType2["Server"] = "server";
})(UserType$1 || (UserType$1 = {}));
var User = class {
  constructor(parameters) {
    this.app = parameters.app;
    this.id = parameters.id;
    this.storage = new UserStorage(this.app.storage, this.id);
    if ("accessToken" in parameters && "refreshToken" in parameters && "providerType" in parameters) {
      this._accessToken = parameters.accessToken;
      this._refreshToken = parameters.refreshToken;
      this.providerType = parameters.providerType;
      this.storage.accessToken = parameters.accessToken;
      this.storage.refreshToken = parameters.refreshToken;
      this.storage.providerType = parameters.providerType;
    } else {
      this._accessToken = this.storage.accessToken;
      this._refreshToken = this.storage.refreshToken;
      const providerType = this.storage.providerType;
      this._profile = this.storage.profile;
      if (providerType) {
        this.providerType = providerType;
      } else {
        throw new Error("Storage is missing a provider type");
      }
    }
    this.fetcher = this.app.fetcher.clone({
      userContext: { currentUser: this }
    });
    this.apiKeys = new ApiKeyAuth(this.fetcher);
    this.functions = FunctionsFactory.create(this.fetcher);
  }
  get accessToken() {
    return this._accessToken;
  }
  set accessToken(token) {
    this._accessToken = token;
    this.storage.accessToken = token;
  }
  get refreshToken() {
    return this._refreshToken;
  }
  set refreshToken(token) {
    this._refreshToken = token;
    this.storage.refreshToken = token;
  }
  get state() {
    if (this.id in this.app.allUsers) {
      return this.refreshToken === null ? UserState.LoggedOut : UserState.Active;
    } else {
      return UserState.Removed;
    }
  }
  get isLoggedIn() {
    return this.state === UserState.Active;
  }
  get customData() {
    if (this.accessToken) {
      const decodedToken = this.decodeAccessToken();
      return decodedToken.userData;
    } else {
      throw new Error("Cannot read custom data without an access token");
    }
  }
  get profile() {
    if (this._profile) {
      return this._profile.data;
    } else {
      throw new Error("A profile was never fetched for this user");
    }
  }
  get identities() {
    if (this._profile) {
      return this._profile.identities;
    } else {
      throw new Error("A profile was never fetched for this user");
    }
  }
  get deviceId() {
    if (this.accessToken) {
      const payload = this.accessToken.split(".")[1];
      if (payload) {
        const parsedPayload = JSON.parse(gBase64.decode(payload));
        const deviceId = parsedPayload["baas_device_id"];
        if (typeof deviceId === "string" && deviceId !== DEFAULT_DEVICE_ID) {
          return deviceId;
        }
      }
    }
    return null;
  }
  async refreshProfile() {
    const response = await this.fetcher.fetchJSON({
      method: "GET",
      path: routes.api().auth().profile().path
    });
    this._profile = new UserProfile(response);
    this.storage.profile = this._profile;
  }
  async logOut() {
    try {
      if (this._refreshToken !== null) {
        await this.fetcher.fetchJSON({
          method: "DELETE",
          path: routes.api().auth().session().path,
          tokenType: "refresh"
        });
      }
    } catch (err) {
      if (!(err instanceof Error) || !err.message.includes("failed to find refresh token")) {
        throw err;
      }
    } finally {
      this.accessToken = null;
      this.refreshToken = null;
    }
  }
  async linkCredentials(credentials) {
    const response = await this.app.authenticator.authenticate(credentials, this);
    if (this.id !== response.userId) {
      const details = `got user id ${response.userId} expected ${this.id}`;
      throw new Error(`Link response ment for another user (${details})`);
    }
    this.accessToken = response.accessToken;
    await this.refreshProfile();
  }
  async refreshAccessToken() {
    const response = await this.fetcher.fetchJSON({
      method: "POST",
      path: routes.api().auth().session().path,
      tokenType: "refresh"
    });
    const { access_token: accessToken } = response;
    if (typeof accessToken === "string") {
      this.accessToken = accessToken;
    } else {
      throw new Error("Expected an 'access_token' in the response");
    }
  }
  async refreshCustomData() {
    await this.refreshAccessToken();
    return this.customData;
  }
  callFunction(name, ...args) {
    return this.functions.callFunction(name, ...args);
  }
  toJSON() {
    return {
      id: this.id,
      accessToken: this.accessToken,
      refreshToken: this.refreshToken,
      profile: this._profile,
      state: this.state,
      customData: this.customData
    };
  }
  push() {
    throw new Error("Not yet implemented");
  }
  mongoClient(serviceName) {
    return createService(this.fetcher, serviceName);
  }
  decodeAccessToken() {
    if (this.accessToken) {
      const parts = this.accessToken.split(".");
      if (parts.length !== 3) {
        throw new Error("Expected an access token with three parts");
      }
      const encodedPayload = parts[1];
      const decodedPayload = gBase64.decode(encodedPayload);
      const parsedPayload = JSON.parse(decodedPayload);
      const { exp: expires, iat: issuedAt, sub: subject, user_data: userData = {} } = parsedPayload;
      if (typeof expires !== "number") {
        throw new Error("Failed to decode access token 'exp'");
      } else if (typeof issuedAt !== "number") {
        throw new Error("Failed to decode access token 'iat'");
      }
      return { expires, issuedAt, subject, userData };
    } else {
      throw new Error("Missing an access token");
    }
  }
};
var Credentials = class {
  constructor(providerName, providerType, payload) {
    this.providerName = providerName;
    this.providerType = providerType;
    this.payload = payload;
  }
  static anonymous() {
    return new Credentials("anon-user", "anon-user", {});
  }
  static userApiKey(key) {
    return new Credentials("api-key", "api-key", { key });
  }
  static serverApiKey(key) {
    return new Credentials("api-key", "api-key", { key });
  }
  static apiKey(key) {
    return new Credentials("api-key", "api-key", { key });
  }
  static emailPassword(email, password) {
    return new Credentials("local-userpass", "local-userpass", {
      username: email,
      password
    });
  }
  static function(payload) {
    return new Credentials("custom-function", "custom-function", payload);
  }
  static jwt(token) {
    return new Credentials("custom-token", "custom-token", {
      token
    });
  }
  static google(payload) {
    return new Credentials("oauth2-google", "oauth2-google", Credentials.derivePayload(payload));
  }
  static derivePayload(payload) {
    if (typeof payload === "string") {
      if (payload.includes("://")) {
        return this.derivePayload({ redirectUrl: payload });
      } else if (payload.startsWith("4/")) {
        return this.derivePayload({ authCode: payload });
      } else if (payload.startsWith("ey")) {
        return this.derivePayload({ idToken: payload });
      } else {
        throw new Error(`Unexpected payload: ${payload}`);
      }
    } else if (Object.keys(payload).length === 1) {
      if ("authCode" in payload || "redirectUrl" in payload) {
        return payload;
      } else if ("idToken" in payload) {
        return { id_token: payload.idToken };
      } else {
        throw new Error("Unexpected payload: " + JSON.stringify(payload));
      }
    } else {
      throw new Error("Expected only one property in payload, got " + JSON.stringify(payload));
    }
  }
  static facebook(redirectUrlOrAccessToken) {
    return new Credentials("oauth2-facebook", "oauth2-facebook", redirectUrlOrAccessToken.includes("://") ? { redirectUrl: redirectUrlOrAccessToken } : { accessToken: redirectUrlOrAccessToken });
  }
  static apple(redirectUrlOrIdToken) {
    return new Credentials("oauth2-apple", "oauth2-apple", redirectUrlOrIdToken.includes("://") ? { redirectUrl: redirectUrlOrIdToken } : { id_token: redirectUrlOrIdToken });
  }
};
var USER_IDS_STORAGE_KEY = "userIds";
var DEVICE_ID_STORAGE_KEY = "deviceId";
var AppStorage = class extends PrefixedStorage {
  constructor(storage, appId) {
    super(storage, `app(${appId})`);
  }
  getUserIds() {
    const userIdsString = this.get(USER_IDS_STORAGE_KEY);
    const userIds = userIdsString ? JSON.parse(userIdsString) : [];
    if (Array.isArray(userIds)) {
      return [...new Set(userIds)];
    } else {
      throw new Error("Expected the user ids to be an array");
    }
  }
  setUserIds(userIds, mergeWithExisting) {
    if (mergeWithExisting) {
      const existingIds = this.getUserIds();
      for (const id of existingIds) {
        if (userIds.indexOf(id) === -1) {
          userIds.push(id);
        }
      }
    }
    this.set(USER_IDS_STORAGE_KEY, JSON.stringify(userIds));
  }
  removeUserId(userId) {
    const existingIds = this.getUserIds();
    const userIds = existingIds.filter((id) => id !== userId);
    this.setUserIds(userIds, false);
  }
  getDeviceId() {
    return this.get(DEVICE_ID_STORAGE_KEY);
  }
  setDeviceId(deviceId) {
    this.set(DEVICE_ID_STORAGE_KEY, deviceId);
  }
};
var LOWERCASE_LETTERS = "abcdefghijklmnopqrstuvwxyz";
var CLOSE_CHECK_INTERVAL = 100;
var REDIRECT_HASH_TO_RESULT = {
  _stitch_client_app_id: "appId",
  _baas_client_app_id: "appId",
  _stitch_ua: "userAuth",
  _baas_ua: "userAuth",
  _stitch_link: "link",
  _baas_link: "link",
  _stitch_error: "error",
  _baas_error: "error",
  _stitch_state: "state",
  _baas_state: "state"
};
var OAuth2Helper = class {
  constructor(storage, openWindow2 = getEnvironment().openWindow) {
    this.storage = storage.prefix("oauth2");
    this.openWindow = openWindow2;
  }
  static parseRedirectLocation(queryString) {
    const params = decodeQueryString(queryString);
    const result = {};
    for (const [p, r] of Object.entries(REDIRECT_HASH_TO_RESULT)) {
      const value = params[p];
      if (value) {
        result[r] = value;
      }
    }
    return result;
  }
  static handleRedirect(queryString, storage = getEnvironment().defaultStorage) {
    const result = OAuth2Helper.parseRedirectLocation(queryString);
    const { state, error } = result;
    if (typeof state === "string") {
      const oauth2Storage = storage.prefix("oauth2");
      const stateStorage = OAuth2Helper.getStateStorage(oauth2Storage, state);
      stateStorage.set("result", JSON.stringify(result));
    } else if (error) {
      throw new Error(`Failed to handle OAuth 2.0 redirect: ${error}`);
    } else {
      throw new Error("Failed to handle OAuth 2.0 redirect.");
    }
  }
  static decodeAuthInfo(authInfo) {
    const parts = (authInfo || "").split("$");
    if (parts.length === 4) {
      const [accessToken, refreshToken, userId, deviceId] = parts;
      return { accessToken, refreshToken, userId, deviceId };
    } else {
      throw new Error("Failed to decode 'authInfo' into ids and tokens");
    }
  }
  static getStateStorage(storage, state) {
    return storage.prefix(`state(${state})`);
  }
  openWindowAndWaitForRedirect(url, state) {
    const stateStorage = OAuth2Helper.getStateStorage(this.storage, state);
    return new Promise((resolve, reject) => {
      let redirectWindow = null;
      let windowClosedInterval;
      const handleStorageUpdate = () => {
        const result = stateStorage.get("result");
        if (result) {
          const parsedResult = JSON.parse(result);
          stateStorage.removeListener(handleStorageUpdate);
          stateStorage.clear();
          try {
            if (redirectWindow) {
              clearInterval(windowClosedInterval);
              redirectWindow.close();
            }
          } catch (err) {
            console.warn(`Failed closing redirect window: ${err}`);
          } finally {
            resolve(parsedResult);
          }
        }
      };
      stateStorage.addListener(handleStorageUpdate);
      redirectWindow = this.openWindow(url);
      windowClosedInterval = setInterval(() => {
        if (!redirectWindow) {
          clearInterval(windowClosedInterval);
        } else if (redirectWindow.closed) {
          clearInterval(windowClosedInterval);
          stateStorage.removeListener(handleStorageUpdate);
          const err = new Error("Window closed");
          reject(err);
        }
      }, CLOSE_CHECK_INTERVAL);
    });
  }
  generateState() {
    return generateRandomString(12, LOWERCASE_LETTERS);
  }
};
var REDIRECT_LOCATION_HEADER = "x-baas-location";
var Authenticator = class {
  constructor(fetcher, storage, getDeviceInformation) {
    this.fetcher = fetcher;
    this.oauth2 = new OAuth2Helper(storage);
    this.getDeviceInformation = getDeviceInformation;
  }
  async authenticate(credentials, linkingUser) {
    const deviceInformation = this.getDeviceInformation();
    const isLinking = typeof linkingUser === "object";
    if (credentials.providerType.startsWith("oauth2") && typeof credentials.payload.redirectUrl === "string") {
      const state = this.oauth2.generateState();
      const url = await this.getLogInUrl(credentials, isLinking, {
        state,
        redirect: credentials.payload.redirectUrl,
        providerRedirectHeader: isLinking ? true : void 0,
        device: !isLinking ? deviceInformation.encode() : void 0
      });
      if (isLinking) {
        const response = await this.fetcher.fetch({
          method: "GET",
          url,
          tokenType: isLinking ? "access" : "none",
          user: linkingUser,
          mode: "cors",
          credentials: "include"
        });
        const redirectUrl = response.headers.get(REDIRECT_LOCATION_HEADER);
        if (redirectUrl) {
          return this.openWindowAndWaitForAuthResponse(redirectUrl, state);
        } else {
          throw new Error(`Missing ${REDIRECT_LOCATION_HEADER} header`);
        }
      } else {
        return this.openWindowAndWaitForAuthResponse(url, state);
      }
    } else {
      const logInUrl = await this.getLogInUrl(credentials, isLinking);
      const response = await this.fetcher.fetchJSON({
        method: "POST",
        url: logInUrl,
        body: __spreadProps(__spreadValues({}, credentials.payload), {
          options: {
            device: deviceInformation.toJSON()
          }
        }),
        tokenType: isLinking ? "access" : "none",
        user: linkingUser
      });
      const { user_id: userId, access_token: accessToken, refresh_token: refreshToken = null, device_id: deviceId } = response;
      if (typeof userId !== "string") {
        throw new Error("Expected a user id in the response");
      }
      if (typeof accessToken !== "string") {
        throw new Error("Expected an access token in the response");
      }
      if (typeof refreshToken !== "string" && refreshToken !== null) {
        throw new Error("Expected refresh token to be a string or null");
      }
      if (typeof deviceId !== "string") {
        throw new Error("Expected device id to be a string");
      }
      return { userId, accessToken, refreshToken, deviceId };
    }
  }
  async getLogInUrl(credentials, link = false, extraQueryParams = {}) {
    const appRoute = this.fetcher.appRoute;
    const loginRoute = appRoute.authProvider(credentials.providerName).login();
    const qs = encodeQueryString(__spreadValues({
      link: link ? "true" : void 0
    }, extraQueryParams));
    const locationUrl = await this.fetcher.locationUrl;
    return locationUrl + loginRoute.path + qs;
  }
  async openWindowAndWaitForAuthResponse(redirectUrl, state) {
    const redirectResult = await this.oauth2.openWindowAndWaitForRedirect(redirectUrl, state);
    return OAuth2Helper.decodeAuthInfo(redirectResult.userAuth);
  }
};
var MongoDBRealmError = class extends Error {
  constructor(method, url, statusCode, statusText, error, errorCode, link) {
    const summary = statusText ? `status ${statusCode} ${statusText}` : `status ${statusCode}`;
    if (typeof error === "string") {
      super(`Request failed (${method} ${url}): ${error} (${summary})`);
    } else {
      super(`Request failed (${method} ${url}): (${summary})`);
    }
    this.method = method;
    this.url = url;
    this.statusText = statusText;
    this.statusCode = statusCode;
    this.error = error;
    this.errorCode = errorCode;
    this.link = link;
  }
  static async fromRequestAndResponse(request, response) {
    var _a;
    const { url, method } = request;
    const { status, statusText } = response;
    if ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.startsWith("application/json")) {
      const body = await response.json();
      if (typeof body === "object" && body) {
        const { error, error_code: errorCode, link } = body;
        return new MongoDBRealmError(method, url, status, statusText, typeof error === "string" ? error : void 0, typeof errorCode === "string" ? errorCode : void 0, typeof link === "string" ? link : void 0);
      }
    }
    return new MongoDBRealmError(method, url, status, statusText);
  }
};
function asyncIteratorFromResponseBody(body) {
  if (typeof body !== "object" || body === null) {
    throw new Error("Expected a non-null object");
  } else if (Symbol.asyncIterator in body) {
    return body;
  } else if ("getReader" in body) {
    const stream = body;
    return {
      [Symbol.asyncIterator]() {
        const reader = stream.getReader();
        return {
          next() {
            return reader.read();
          },
          async return() {
            await reader.cancel();
            return { done: true, value: null };
          }
        };
      }
    };
  } else {
    throw new Error("Expected an AsyncIterable or a ReadableStream");
  }
}
var Fetcher = class {
  constructor({ appId, transport, userContext, locationUrlContext }) {
    this.appId = appId;
    this.transport = transport;
    this.userContext = userContext;
    this.locationUrlContext = locationUrlContext;
  }
  static buildAuthorizationHeader(user, tokenType) {
    if (!user || tokenType === "none") {
      return {};
    } else if (tokenType === "access") {
      return { Authorization: `Bearer ${user.accessToken}` };
    } else if (tokenType === "refresh") {
      return { Authorization: `Bearer ${user.refreshToken}` };
    } else {
      throw new Error(`Unexpected token type (${tokenType})`);
    }
  }
  static buildBody(body) {
    if (!body) {
      return;
    } else if (typeof body === "object" && body !== null) {
      return JSON.stringify(serialize(body));
    } else if (typeof body === "string") {
      return body;
    } else {
      console.log("body is", body);
      throw new Error("Unexpected type of body");
    }
  }
  static buildJsonHeader(body) {
    if (body && body.length > 0) {
      return { "Content-Type": "application/json" };
    } else {
      return {};
    }
  }
  clone(config) {
    return new Fetcher(__spreadValues({
      appId: this.appId,
      transport: this.transport,
      userContext: this.userContext,
      locationUrlContext: this.locationUrlContext
    }, config));
  }
  async fetch(request) {
    const _a = request, { path, url, tokenType = "access", user = this.userContext.currentUser } = _a, restOfRequest = __objRest(_a, ["path", "url", "tokenType", "user"]);
    if (typeof path === "string" && typeof url === "string") {
      throw new Error("Use of 'url' and 'path' mutually exclusive");
    } else if (typeof path === "string") {
      const url2 = await this.locationUrlContext.locationUrl + path;
      return this.fetch(__spreadProps(__spreadValues({}, request), { path: void 0, url: url2 }));
    } else if (typeof url === "string") {
      const response = await this.transport.fetch(__spreadProps(__spreadValues({}, restOfRequest), {
        url,
        headers: __spreadValues(__spreadValues({}, Fetcher.buildAuthorizationHeader(user, tokenType)), request.headers)
      }));
      if (response.ok) {
        return response;
      } else if (user && response.status === 401 && tokenType === "access") {
        await user.refreshAccessToken();
        return this.fetch(__spreadProps(__spreadValues({}, request), { user }));
      } else {
        if (user && response.status === 401 && tokenType === "refresh") {
          user.accessToken = null;
          user.refreshToken = null;
        }
        throw await MongoDBRealmError.fromRequestAndResponse(request, response);
      }
    } else {
      throw new Error("Expected either 'url' or 'path'");
    }
  }
  async fetchJSON(request) {
    const { body } = request;
    const serializedBody = Fetcher.buildBody(body);
    const contentTypeHeaders = Fetcher.buildJsonHeader(serializedBody);
    const response = await this.fetch(__spreadProps(__spreadValues({}, request), {
      body: serializedBody,
      headers: __spreadValues(__spreadValues({
        Accept: "application/json"
      }, contentTypeHeaders), request.headers)
    }));
    const contentType = response.headers.get("content-type");
    if (contentType === null || contentType === void 0 ? void 0 : contentType.startsWith("application/json")) {
      const responseBody = await response.json();
      return deserialize(responseBody);
    } else if (contentType === null) {
      return null;
    } else {
      throw new Error(`Expected JSON response, got "${contentType}"`);
    }
  }
  async fetchStream(request) {
    const { body } = await this.fetch(__spreadProps(__spreadValues({}, request), {
      headers: __spreadValues({
        Accept: "text/event-stream"
      }, request.headers)
    }));
    return asyncIteratorFromResponseBody(body);
  }
  get appRoute() {
    return routes.api().app(this.appId);
  }
  get locationUrl() {
    return this.locationUrlContext.locationUrl;
  }
};
var DEVICE_ID_STORAGE_KEY$1 = "deviceId";
var DeviceFields;
(function(DeviceFields2) {
  DeviceFields2["DEVICE_ID"] = "deviceId";
  DeviceFields2["APP_ID"] = "appId";
  DeviceFields2["APP_VERSION"] = "appVersion";
  DeviceFields2["PLATFORM"] = "platform";
  DeviceFields2["PLATFORM_VERSION"] = "platformVersion";
  DeviceFields2["SDK_VERSION"] = "sdkVersion";
})(DeviceFields || (DeviceFields = {}));
var DeviceInformation = class {
  constructor({ appId, appVersion, deviceId }) {
    this.sdkVersion = "1.7.0";
    const environment2 = getEnvironment();
    this.platform = environment2.platform;
    this.platformVersion = environment2.platformVersion;
    this.appId = appId;
    this.appVersion = appVersion;
    this.deviceId = deviceId;
  }
  encode() {
    const obj = removeKeysWithUndefinedValues(this);
    return gBase64.encode(JSON.stringify(obj));
  }
  toJSON() {
    return removeKeysWithUndefinedValues(this);
  }
};
var DEFAULT_BASE_URL = "https://realm.mongodb.com";
var App = class {
  constructor(idOrConfiguration) {
    this.users = [];
    this._locationUrl = null;
    const configuration = typeof idOrConfiguration === "string" ? { id: idOrConfiguration } : idOrConfiguration;
    if (typeof configuration === "object" && typeof configuration.id === "string") {
      this.id = configuration.id;
    } else {
      throw new Error("Missing a MongoDB Realm app-id");
    }
    this.baseUrl = configuration.baseUrl || DEFAULT_BASE_URL;
    if (configuration.skipLocationRequest) {
      this._locationUrl = Promise.resolve(this.baseUrl);
    }
    this.localApp = configuration.app;
    const { storage, transport = new DefaultNetworkTransport() } = configuration;
    this.fetcher = new Fetcher({
      appId: this.id,
      userContext: this,
      locationUrlContext: this,
      transport
    });
    this.emailPasswordAuth = new EmailPasswordAuth(this.fetcher);
    const baseStorage = storage || getEnvironment().defaultStorage;
    this.storage = new AppStorage(baseStorage, this.id);
    this.authenticator = new Authenticator(this.fetcher, baseStorage, () => this.deviceInformation);
    try {
      this.hydrate();
    } catch (err) {
      this.storage.clear();
      console.warn("Realm app hydration failed:", err instanceof Error ? err.message : err);
    }
  }
  static getApp(id) {
    if (id in App.appCache) {
      return App.appCache[id];
    } else {
      const instance = new App(id);
      App.appCache[id] = instance;
      return instance;
    }
  }
  switchUser(nextUser) {
    const index = this.users.findIndex((u) => u === nextUser);
    if (index === -1) {
      throw new Error("The user was never logged into this app");
    }
    const [user] = this.users.splice(index, 1);
    this.users.unshift(user);
  }
  async logIn(credentials, fetchProfile = true) {
    const response = await this.authenticator.authenticate(credentials);
    const user = this.createOrUpdateUser(response, credentials.providerType);
    this.switchUser(user);
    if (fetchProfile) {
      await user.refreshProfile();
    }
    this.storage.setUserIds(this.users.map((u) => u.id), true);
    const deviceId = response.deviceId;
    if (deviceId && deviceId !== "000000000000000000000000") {
      this.storage.set(DEVICE_ID_STORAGE_KEY$1, deviceId);
    }
    return user;
  }
  async removeUser(user) {
    const index = this.users.findIndex((u) => u === user);
    if (index === -1) {
      throw new Error("The user was never logged into this app");
    }
    this.users.splice(index, 1);
    await user.logOut();
    this.storage.remove(`user(${user.id}):profile`);
    this.storage.removeUserId(user.id);
  }
  async deleteUser(user) {
    await this.fetcher.fetchJSON({
      method: "DELETE",
      path: routes.api().auth().delete().path
    });
    await this.removeUser(user);
  }
  get currentUser() {
    const activeUsers = this.users.filter((user) => user.state === UserState.Active);
    if (activeUsers.length === 0) {
      return null;
    } else {
      return activeUsers[0];
    }
  }
  get allUsers() {
    return Object.fromEntries(this.users.map((user) => [user.id, user]));
  }
  get locationUrl() {
    if (!this._locationUrl) {
      const path = routes.api().app(this.id).location().path;
      this._locationUrl = this.fetcher.fetchJSON({
        method: "GET",
        url: this.baseUrl + path,
        tokenType: "none"
      }).then((body) => {
        if (typeof body !== "object") {
          throw new Error("Expected response body be an object");
        } else {
          return body;
        }
      }).then(({ hostname }) => {
        if (typeof hostname !== "string") {
          throw new Error("Expected response to contain a 'hostname'");
        } else {
          return hostname;
        }
      }).catch((err) => {
        this._locationUrl = null;
        throw err;
      });
    }
    return this._locationUrl;
  }
  get deviceInformation() {
    const deviceIdStr = this.storage.getDeviceId();
    const deviceId = typeof deviceIdStr === "string" && deviceIdStr !== "000000000000000000000000" ? new ObjectId(deviceIdStr) : void 0;
    return new DeviceInformation({
      appId: this.localApp ? this.localApp.name : void 0,
      appVersion: this.localApp ? this.localApp.version : void 0,
      deviceId
    });
  }
  createOrUpdateUser(response, providerType) {
    const existingUser = this.users.find((u) => u.id === response.userId);
    if (existingUser) {
      existingUser.accessToken = response.accessToken;
      existingUser.refreshToken = response.refreshToken;
      return existingUser;
    } else {
      if (!response.refreshToken) {
        throw new Error("No refresh token in response from server");
      }
      const user = new User({
        app: this,
        id: response.userId,
        accessToken: response.accessToken,
        refreshToken: response.refreshToken,
        providerType
      });
      this.users.unshift(user);
      return user;
    }
  }
  hydrate() {
    const userIds = this.storage.getUserIds();
    this.users = userIds.map((id) => new User({ app: this, id }));
  }
};
App.appCache = {};
App.Credentials = Credentials;
function getApp(id) {
  return App.getApp(id);
}
var LocalStorage = class {
  constructor() {
    if (typeof globalThis.localStorage === "object") {
      this.global = globalThis;
    } else {
      throw new Error("Cannot use LocalStorage without a global localStorage object");
    }
  }
  get(key) {
    return this.global.localStorage.getItem(key);
  }
  set(key, value) {
    return this.global.localStorage.setItem(key, value);
  }
  remove(key) {
    return this.global.localStorage.removeItem(key);
  }
  prefix(keyPart) {
    return new PrefixedStorage(this, keyPart);
  }
  clear(prefix) {
    const keys = [];
    for (let i = 0; i < this.global.localStorage.length; i++) {
      const key = this.global.localStorage.key(i);
      if (key && (!prefix || key.startsWith(prefix))) {
        keys.push(key);
      }
    }
    for (const key of keys) {
      this.global.localStorage.removeItem(key);
    }
  }
  addListener(listener) {
    return this.global.addEventListener("storage", listener);
  }
  removeListener(listener) {
    return this.global.removeEventListener("storage", listener);
  }
};
var browser = detect();
var DefaultStorage = "localStorage" in globalThis ? LocalStorage : MemoryStorage;
function openWindow(url) {
  if (typeof globalThis.open === "function") {
    return globalThis.open(url);
  } else {
    console.log(`Please open ${url}`);
    return null;
  }
}
var environment$1 = {
  defaultStorage: new DefaultStorage().prefix("realm-web"),
  openWindow,
  platform: (browser === null || browser === void 0 ? void 0 : browser.name) || "web",
  platformVersion: (browser === null || browser === void 0 ? void 0 : browser.version) || "0.0.0",
  TextDecoder
};
setEnvironment(environment$1);
function handleAuthRedirect(location = globalThis.location, storage = environment$1.defaultStorage) {
  try {
    const queryString = location.hash.substr(1);
    OAuth2Helper.handleRedirect(queryString, storage);
  } catch (err) {
    console.warn(err);
  }
}
export {
  App,
  bson_browser_esm_exports as BSON,
  Credentials,
  DEFAULT_BASE_URL,
  LocalStorage,
  MongoDBRealmError,
  User,
  UserState,
  UserType$1 as UserType,
  getApp,
  getEnvironment,
  handleAuthRedirect,
  setEnvironment
};
//# sourceMappingURL=realm-web.js.map
